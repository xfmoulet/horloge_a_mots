// This file is a custom build script
// It is run , generating LED code to src/data.rs

use std::collections::HashMap;
use std::fs::File;
use std::io::Write;

#[cfg(feature="big_panel")]
include!{"big_panel.rs"}

#[cfg(feature="mini_panel")]
include!{"mini_panel"}

#[cfg(feature="mini_demo")]
include!{"mini_demo"}


// Code Gen ------------------------------------------------------------------------------------

// Write to a file the table of option<LED>s (with name `title`, of `max_leds` size) from a list of strings (`elts`), repeating the LEDs accordingly to the durations table
fn write_elements<'a>(
    file: &mut File,
    title: &str,
    elts: &[&'a str],
    durations: &HashMap<&str, usize>,
) {
    let max_leds = elts
        .iter()
        .map(|s| {
            if !s.is_empty() {
                s.split(' ').map(|word| *durations.get(word).unwrap()).sum()
            } else {
                0
            }
        })
        .fold(0, |a, b| a.max(b));

    writeln!(file, "pub const NB_{} : usize = {};", title, max_leds).unwrap();
    writeln!(
        file,
        "pub static {}: [[Option<LED>;NB_{}];{}] = [",
        title,
        title,
        elts.len()
    )
    .unwrap();

    for words in elts.iter() {
        write!(file, "    [").unwrap();
        let mut leds = 0;
        if !words.is_empty() {
            for word in words.split(' ') {
                let nb = *durations.get(word).unwrap(); // word.len() / 3 +1
                leds += nb; // total used so far
                for _ in 0..nb {
                    write!(file, "Some(LED::{}), ", word).unwrap();
                }
            }
        }

        /* Insert None LEDs in unused slots.
           Trying to skip None/merge hours and minutes between hours and min5 by example
           is not useful since all combinations will happen so we must support worst case.
        */
        for _ in leds..max_leds {
            write!(file, "None, ").unwrap();
        }
        writeln!(file, "],").unwrap();
    }
    writeln!(file, "];").unwrap();
}

// slow find but not necessary to optimize
fn led_position(name: &str) -> Option<(u8, u8)> {
    for (line, words) in LED_PANEL.iter().enumerate() {
        for (column, word) in words.split(' ').enumerate() {
            if word == name {
                return Some((column as u8, line as u8));
            }
        }
    }
    None
}


fn write_patterns(file: &mut File) -> Result<(),std::io::Error> {
    file.write_all(b"// Interleaving patterns for 32 values and 32 ticks\npub const INTERLEAVE_PATTERNS: [u32;32] = [\n")?;
    for value in 0..32 {
        write!(file, "    0b")?;
        for tick in 0..32 {
            let a = (tick + 1) * value / 32;
            let b = (tick + 0) * value / 32;
            file.write_all(if a != b { b"1" } else { b"0" })?;
        // print(value, sum(1 for a in s if a == "*"), s)
        }
        writeln!(file,",")?
    }
    file.write_all(b"];")?;
    Ok(())
}

// Generate the src/data.rs file according to LED tables
fn main() {
    let mut file = File::create("./src/data.rs").unwrap();

    writeln!(
        &mut file,
        "// horloge a mots data - file generated by build.rs"
    )
    .unwrap();

    // write all words enum
    writeln!(&mut file, "#[derive(Debug, Clone, Copy, PartialEq)]").unwrap();

    let led_durations = HashMap::from(LED_DURATIONS);

    // LED enum
    writeln!(&mut file, "pub enum LED {{").unwrap();
    for (word, _len) in LED_DURATIONS.iter() {
        writeln!(&mut file, "    {word},").unwrap();
    }
    writeln!(&mut file, "}}").unwrap();

    // LED positions
    writeln!(
        &mut file,
        "pub static LED_POSITIONS: [(u8, u8); {}] = [",
        LED_DURATIONS.len()
    )
    .unwrap();
    for (word, _len) in LED_DURATIONS.iter() {
        if let Some((column, line)) = led_position(word) {
            writeln!(&mut file, "    ({column}, {line}), // {word}").unwrap();
        } else {
            panic!("position not found for LED {word}");
        }
    }
    writeln!(&mut file, "];").unwrap();

    // LED hours tables
    writeln!(&mut file, "// ---").unwrap();
    write_elements(&mut file, "HOURS_LED", &HOURS_LED, &led_durations);
    writeln!(&mut file, "// ---").unwrap();
    write_elements(&mut file, "MIN5_LED", &MINUTES_5_LED, &led_durations);
    writeln!(&mut file, "// ---").unwrap();
    write_elements(&mut file, "MINUTES_LED", &MINUTES_LED, &led_durations);

    writeln!(&mut file, "// ---").unwrap();
    write_patterns(&mut file).unwrap();
}
